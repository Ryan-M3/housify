# Housify

This project is an implementation of the method described in the paper
*Automatic Real-Time Generation of Floor Plans Based on Squarified Treemaps
Algorithm*. I heavily referenced *Squarified Treemaps* when implementing and
testing the program. I also used a random auto-CAD handout I found online to
generate plausible room sizes.

This project uses *github.com/fogleman/gg* for render generated images to file.

Automatic Real-Time Generation of Floor Plans Based on Squarified Treemaps Algorithm

    @article{article,
		author = {Marson, Fernando and Musse, Soraia},
		year = {2010},
		month = {09},
		pages = {},
		title = {Automatic Real-Time Generation of Floor Plans Based on Squarified Treemaps Algorithm},
		volume = {2010},
		journal = {International Journal of Computer Games Technology},
		doi = {10.1155/2010/624817}
	}


Squarified Treemaps

    @INPROCEEDINGS{Bruls99squarifiedtreemaps,
		author = {Mark Bruls and Kees Huizing and Jarke van Wijk},
		title = {Squarified Treemaps},
		booktitle = {In Proceedings of the Joint Eurographics and IEEE TCVG Symposium on Visualization},
		year = {1999},
		pages = {33--42},
		publisher = {Press}
	}

## The Algorithm

### Floorplan Generation

1. Use the Squarified Treemap algorithm to subdivide an arbitrary rectangle
   into three functional areas: social, private, and service.

2. Recursively squarify each functional area into the appropriate rooms (bed
   and bath in private, kitchen and laundry in service, and living and dining
   in social).

3. Interpreting the corner of each room as a node in a graph connected to other
   nodes in the graph via walls, create a "backbone" (basically a minimum
   spanning tree) that connects every room in the house.

4. Resize each room to create a corridor/hallways where the backbone was.

5. If the process or resizing creates pathologically sized or shaped rooms,
   adjust the desired area of those rooms upwards and redraw the floorplans.

### Squarified Treemaps

Treemaps are a visualization of trees of numbers that recursively subdivides a
rectangle into smaller rectangles such that each subrectangle's area matches
the number in the treee. A classic use-case is visualizing disk-space usage:
the area of the resulting tree represents how much disk space that file or
folder uses, and in the case of folders that rectangle is further subdivided
into smaller rectangle matching the disk usage of the files inside that folder
(which may include further subdivided folders...). 

The obvious approach to treemapping is to convert all absolute values to
proportions of the whole, and, starting with the biggest item, cut the
rectangle long-ways. Then repeat the process for the remaining values inside
the remaining area of the rectangle.

Unfortunately, that approach produces more long and skinny rectangles than you
would expect. On the other hand, checking every possible configuration is
computationally infeasible.

The Squarified Treemap algorithm uses a formula to determine when to switch
from subdividing a rectangle vertically to/from subdividing it horizontally.
More information about its implemenation can be found in the original paper or
later in this code walk-through.

## Project Navigation

Most functions have a comment above them summarizing them, sometimes with
primitive ASCII art for further illustration. For more details than this
README, check the source code.

### main.go
    Ties everything in the project together into the following algorithm:
	1. stochastically generate room areas
	2. apply the squarified treemap algorithm to the room areas
	3. insert doors to adjacent rooms, depending on room type
	4. generate the backbone of the treemap
	5. insert a hallway, adding some doors in the process
	6. draw the house and save the file to disk as out.png

### astar.go
	The A* search algorithm used to generate the backbone of the building. The
	backbone is generated by find the A* distance from the corner of the living
	room to every other room in the house, then combining those paths into a
	single brnaching structure. The paper cited above discarded the living room
	entirely, but my implementation had terrible results when I did that.

### backbone.go
	Generates the backbone of the house in tandem with astar.go.

### draw.go
	Drawing functions. Mostly placing squares and text and the correct places.

### gen.go
	Functions for randomly generating house data based and loading info from
	/data/.

### hallway.go
	Functions for inserting a hallway, which also adds some doors in the process.

### interiorDoors.go
	The logic for adding doors between adjacent rooms.

### sqrfy.go
	The Squarified Treemap algorithm.


### /data/room_edges.csv
	Which rooms can connect to other rooms.

### /data/room_sizes.csv
	Typical size of rooms.

### /data/ubuntu.ttf
	Font used to label output images.


### dataStructures/conversions.go
	Convert from certain dataStructures to others. For instance, turn a line
	into two point.

### dataStructures/dir.go
	N, E, S, and W enum

### dataStructures/door.go
	a door struct

### dataStructures/graph.go
	A graph is a mapping of point-to-points.

### dataStructures/line.go
	A line or edge (two points in 2D euclidean space). Includes a lot of
	methods and functions, like whether two lines intersect, whether they are
	horizontal or vertical, and a function for turning two overlapping lines
	into three non-overlapping lines.

### dataStructures/list.go
	Helpful methods for working with lists.

### dataStructures/pt.go
	A 2D vector.

### dataStructures/rect.go
	A tone of methods surrounding working with rectangles, which are
	represented by their lower left and upper right corners. Includes methods
	for resizing rectangles, bisecting them, and stacking them in rows or
	columns (which is very useful for the squarified treemap algorithm).

### dataStructures/room.go
	A room is a rectangle, a list of doors, and a list of adjacent rooms.

### dataStructures/tree_float64.go
	FTree: A tree of floating point numbers.

### dataStructures/tree_rect.go
	RTree: A tree of rectangles. Used primarily to represent rooms in a house
	before we start adding doors.
